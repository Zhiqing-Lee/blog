<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Zhiqing&#39;s Blog</title>
  <meta name="description" content="Hello, world!" />
  <meta name="keywords" content="zhiqing,java,android,志青" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一个只会写hello world的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Zhiqing&#39;s Blog">
<meta property="og:url" content="http://blog.zhiqing.info/page/2/index.html">
<meta property="og:site_name" content="Zhiqing&#39;s Blog">
<meta property="og:description" content="一个只会写hello world的博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Zhiqing&#39;s Blog">
<meta name="twitter:description" content="一个只会写hello world的博客">
  
  
    <link rel="icon" href="/images/avatar.png">
  

	<script src="https://use.typekit.net/eyf3hir.js"></script>
  <script>try{Typekit.load({ async: false });}catch(e){}</script>
  <link rel="stylesheet" href="/style.css">
  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
  

</head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>

  <script>setLoadingBarProgress(20)</script>
  
  <div id="site-wrapper">
    
    <header id="header">
	<div id="header-wrapper" class="clearfix">
		<a id="logo" href="/">
			<img src="/images/logo.png" />
			<span id="site-desc">
			  Hello, world!
      </span>
		</a>
		<button id="site-nav-switch">
	    <span class="icon icon-menu"></span>
	  </button>
	</div>
	<aside id="site-menu">
  	<nav>
  		
        <a href="/" class="nav-home nav">
          主页
        </a>
      
        <a href="/archives" class="nav-archives nav">
          归档
        </a>
      
        <a href="http://studio.zhiqing.info" class="nav-studio nav">
          工作
        </a>
      
        <a href="/about" class="nav-about nav">
          关于
        </a>
      
    </nav>
	</aside>
</header>
    <script>setLoadingBarProgress(40);</script>
    
    <main id="main" role="main">
      





<section class="post-list">
	
    <article class="post ">

  
  <h2 class="title">
    <a href="/2016/07/20/linux-pocket-guide-2/">
      《Linux pocket guide》读书笔记之二：Shell特性
    </a>
  </h2>
  
  <time>
    Jul 20, 2016
  </time>
  <section class="content">
	  <p>使用Linux操作系统时，通常是在一个叫Shell的东西里输入命令然后敲入回车，从而让Linux执行相应的程序。比如在Shell中输入<code>who</code>然后敲入回车，系统将会输出有哪些用户在什么地方登录了该计算机。</p>
<ul>
<li><code>|</code> 为管道符，用于链接两条命令，作用是将第一条命令的输出作为第二条命令的输入。如<code>who | wc -l</code>将会显示当前有多少用户登录了该计算机（<code>wc -l</code>命令的功能为显示输入数据的行数）。</li>
<li><code>echo $SHELL</code> 可以显示shell的类型，大多数linux发型版都默认为bash(the Bourne-Again Shell)，输出为<code>/bin/bash</code>。</li>
<li><code>exit</code> 退出当前shell</li>
</ul>
<h2 id="Shell命令对应的程序"><a href="#Shell命令对应的程序" class="headerlink" title="Shell命令对应的程序"></a>Shell命令对应的程序</h2><p>当你输入一条命令时，实际上是调用了一个linux程序或者是一条内置的命令。可以使用<code>type</code>命令显示一个命令的类型或程序的位置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> who  <span class="comment">#输出: who is /usr/bin/who</span></span><br><span class="line"><span class="built_in">type</span> <span class="built_in">cd</span>  <span class="comment">#输出: cd is a shell builtin</span></span><br></pre></td></tr></table></figure>
<h2 id="bash的特点"><a href="#bash的特点" class="headerlink" title="bash的特点"></a>bash的特点</h2><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>通配符是用来代替一个或多个字符的符号，例如：<code>a*</code>的意思是所有以字符<code>a</code>开头的文件。如果在shell中输入<code>ls a*</code>会显示当前文件夹下所有以<code>a</code>开头的文件。和输入<code>ls apple applet ada</code>效果相同。</p>
<blockquote>
<p>ls命令并不知道你使用了通配符，通配符是由shell处理的，所以原则上每个命令都能使用通配符。</p>
</blockquote>
<p>点文件：</p>
<blockquote>
<p>点文件是指文件名以英文句点开头的文件，如：<code>.profile</code>。这种文件在很多程序中默认是不可见的，也被称为隐藏文件</p>
<ul>
<li><code>ls</code> 命令默认不显示点文件，除非加上<code>-a</code>选项</li>
<li>shell的通配符不匹配点文件</li>
</ul>
</blockquote>
<p>通配符：</p>
<ul>
<li><code>*</code> 零个或多个字符</li>
<li><code>?</code> 单个字符</li>
<li><code>[set]</code> 给定集合中的任意字符，如:<code>[aeiouAEIOU]</code>将匹配任意一个元音字母，也可以给定一个范围，如:<code>[A-Z]</code>将匹配任意一个大写字母</li>
<li><code>[^set]</code> 匹配任意一个不在给定集合中的字符，如<code>[^0-9]</code>就爱那个匹配一个不是数字的字符</li>
<li><code>[!set]</code> 同<code>[^set]</code></li>
</ul>
<h3 id="大括号匹配"><a href="#大括号匹配" class="headerlink" title="大括号匹配"></a>大括号匹配</h3><p>和通配符类似，大括号里的表达式将会被分为多个参数传给命令：</p>
<p><code>{X,YY,ZZZ}</code></p>
<p>shell会分别把X、YY、ZZZ传给命令行，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> sand&#123;X,YY,ZZZ&#125;wich  </span><br><span class="line"><span class="comment">#输出：sandXwich sandYYwich sandZZZwich</span></span><br></pre></td></tr></table></figure>
<h3 id="Shell变量"><a href="#Shell变量" class="headerlink" title="Shell变量"></a>Shell变量</h3><p>你可以定义变量并赋值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MYVAR=3</span><br></pre></td></tr></table></figure>
<p>通过美元符号加变量名可以取出变量的值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$MYVAR</span>  <span class="comment">#输出： 3</span></span><br></pre></td></tr></table></figure>
<p>在启动shell之前系统通常会帮你定义的一些变量：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>DISPLAY</td>
<td>显示器名称</td>
</tr>
<tr>
<td>HOME</td>
<td>家目录地址，如：<code>/home/zhiqing</code></td>
</tr>
<tr>
<td>LOGNAME</td>
<td>登录的用户名，如：<code>zhiqing</code></td>
</tr>
<tr>
<td>OLDPWD</td>
<td>上一个<code>cd</code>命令执行之前的目录</td>
</tr>
<tr>
<td>PATH</td>
<td>shell搜索路径，用<code>:</code>分隔的目录</td>
</tr>
<tr>
<td>PWD</td>
<td>当前目录</td>
</tr>
<tr>
<td>SHELL</td>
<td>shell的路径，如：<code>/bin/bash</code></td>
</tr>
<tr>
<td>TERM</td>
<td>终端的类型，如：<code>xterm</code></td>
</tr>
<tr>
<td>USER</td>
<td>当前登录的用户名</td>
</tr>
</tbody>
</table>
<p>变量的作用域一般是默认是当前Shell，如果想让其他shell和程序也能调用该变量，需使用<code>export</code>命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MYVAR=3</span><br><span class="line"><span class="built_in">export</span> MYVAR  </span><br><span class="line"><span class="built_in">export</span> MYVAR2=3  <span class="comment">#功能和上两行一样</span></span><br></pre></td></tr></table></figure>
<p>这样的变量叫做<code>环境变量(environment variable)</code>,通过<code>printenv</code>命令可以输出环境变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">printenv  <span class="comment">#输出所有环境变量</span></span><br><span class="line">printenv HOME  <span class="comment">#输出单个环境变量，输出：`/home/zhiqing`</span></span><br><span class="line">HOME=/home/tom printenv HOME  <span class="comment">#输出:`/home/tom`</span></span><br><span class="line">printenv HOME  <span class="comment">#输出：`/home/zhiqing`</span></span><br></pre></td></tr></table></figure>
<p>如上所示，如需临时改变环境变量的值，可在命令前加上<code>变量=值</code>。</p>
<h3 id="搜索路径-PATH"><a href="#搜索路径-PATH" class="headerlink" title="搜索路径(PATH)"></a>搜索路径(PATH)</h3><p>Linux系统中的程序存放在各种各样的目录中，如<code>/bin</code>、<code>/usr/bin</code>、<code>/opt/java/jdk/bin</code>。为了方便shell能够正确找到该程序，shell提供了<code>PATH</code>环境变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span>  <span class="comment">#输出：`/usr/local/bin:/bin:/usr/bin`</span></span><br></pre></td></tr></table></figure>
<p>如上所示，PATH中的值是用<code>:</code>分隔的多个目录。shell执行程序时会在这些目录中一个一个地查找，找到了便运行该程序，否则提示<code>bash: who: command not found</code>。</p>
<p>你也可以添加自己的程序目录到环境变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PATH=<span class="variable">$PATH</span>:/home/zhiqing/prog</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span>  </span><br><span class="line"><span class="comment">#输出:`/usr/local/bin:/bin:/usr/bin:/homae/zhiqing/prog`</span></span><br></pre></td></tr></table></figure>
<p>这样只会影响当前shell，在<code>~/.bash_profile</code>文件中设置PATH变量可使以后每次开启Shell自动设置。</p>
<h3 id="别名-Aliases"><a href="#别名-Aliases" class="headerlink" title="别名(Aliases)"></a>别名(Aliases)</h3><p>可以使用内置的<code>alias</code>命令为长命令创建别名以方便记忆和输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> ll=<span class="string">'ls -lG'</span></span><br><span class="line">ll  <span class="comment">#此时`ll`与`ls -lG`的输出相同</span></span><br></pre></td></tr></table></figure>
<p>在<code>~/.bash_profile</code>中定义别名，可以使以后登录后直接使用你定义的别名。</p>
<h3 id="输入-输出重定向"><a href="#输入-输出重定向" class="headerlink" title="输入/输出重定向"></a>输入/输出重定向</h3><p>Shell可以把<code>srandard input(标准输入)</code>、<code>srandard output(标准输出)</code>、<code>srandard error(标准错误输出)</code>重定向到文件或从文件重定向：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> &lt; infile  <span class="comment">#重定向文件到标准输入</span></span><br><span class="line"><span class="built_in">command</span> &gt; outfile  <span class="comment">#重定向标准输出到一个文件（创建新文件/覆盖就文件）</span></span><br><span class="line"><span class="built_in">command</span> &gt;&gt; outfile  <span class="comment">#重定向标准输出到一个文件（追加到文件之后）</span></span><br><span class="line"><span class="built_in">command</span> 2&gt; errorfile  <span class="comment">#重定向标准错误输出到文件</span></span><br><span class="line"><span class="built_in">command</span> &gt; outfile 2&gt; errorfile  </span><br><span class="line"><span class="comment">#分别重定向标准输出和标准错误输出到不同的文件</span></span><br><span class="line"><span class="built_in">command</span> &gt;&amp; outfile</span><br><span class="line"><span class="built_in">command</span> &amp;&gt; outfile</span><br><span class="line"><span class="comment">#以上两个均为重定向标准输出和标准错误输出到一个共同的文件</span></span><br></pre></td></tr></table></figure>
<h3 id="管道-Pipes"><a href="#管道-Pipes" class="headerlink" title="管道(Pipes)"></a>管道(Pipes)</h3><p>使用管道(<code>|</code>)你可以重定向一条命令的标准输出到另一条命令的标准输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls | wc -l  <span class="comment">#输出当前目录下的文件个数</span></span><br><span class="line">ls | wc -l | cowsay  <span class="comment">#让一只母牛说出当前目录下的文件个数</span></span><br></pre></td></tr></table></figure>
<h3 id="子过程"><a href="#子过程" class="headerlink" title="子过程"></a>子过程</h3><p>与管道类似，使用子过程<code>&lt;(command)</code>可以把一条命令的输出以文件的形式重定向到另一条命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;(ls | wc -l | cowsay)</span><br><span class="line"><span class="comment">#让一只母牛说出当前目录下的文件个数，但`cat`命令接收的参数为文件</span></span><br></pre></td></tr></table></figure>
<h3 id="执行多条命令"><a href="#执行多条命令" class="headerlink" title="执行多条命令"></a>执行多条命令</h3><p>用<code>;</code>分隔一行内的多条命令，可以使这些命令按次序依次执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">command1 ; command2 ; command3</span><br><span class="line"><span class="comment">#依次执行command1, command2, command3</span></span><br></pre></td></tr></table></figure>
<p>用<code>&amp;&amp;</code>分隔一行内的多条命令，可以使前面的所有命令均执行成功再执行后面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">command1 &amp;&amp; command2 &amp;&amp; command3</span><br><span class="line"><span class="comment">#先执行command1，如成功则执行command2，否则退出</span></span><br><span class="line"><span class="comment">#command1和command2均执行成功才会执行command3</span></span><br></pre></td></tr></table></figure>
<p>用<code>||</code>分隔一行内的多条命令，可以使前面的所有命令中只要有一条执行成功则执行后面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">command1 || command2 || command3</span><br><span class="line"><span class="comment">#先执行command1，如成功则执行command2，否则退出</span></span><br><span class="line"><span class="comment">#command1和command2只要有一条执行成功会执行command3</span></span><br></pre></td></tr></table></figure>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>通常一条命令的参数中如过有空格，则该参数会被分为多个参数传递给命令。如需传递包含空格的参数，需使用单引号<code>‘</code>或双引号<code>&quot;</code>引起来。双引号中的字符串会被解析而单引号不会：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'HOME变量的值为$HOME'</span></span><br><span class="line"><span class="comment">#输出：HOME变量的值为$HOME</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"HOME变量的值为<span class="variable">$HOME</span>"</span></span><br><span class="line"><span class="comment">#输出：HOME变量的值为/home/zhiqing</span></span><br></pre></td></tr></table></figure>
<p>一对反引号(`)中可以包含一条命令，该处的内容会被命令的输出所代替：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date +%Y  <span class="comment">#输出当前年：2016</span></span><br><span class="line"><span class="built_in">echo</span> This year is `date +%Y`  <span class="comment">#输出：This year is 2016-07</span></span><br></pre></td></tr></table></figure>
<p><code>$(command)</code>有同样的功能，但是使用<code>$(command)</code>更好,因为它可以嵌套：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> This year is $(date +%Y)  <span class="comment">#输出：This year is 2016</span></span><br><span class="line"><span class="built_in">echo</span> This year is $(expr $(date +%Y) + 1)</span><br><span class="line"><span class="comment">#输出：This year is 2017</span></span><br></pre></td></tr></table></figure>
<h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>有时候你想在参数中包含已被Shell使用的特殊符号，如<code>*</code>、<code>$</code>，这时可以使用转义符<code>\</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> a*  <span class="comment">#输出：apple applet app</span></span><br><span class="line"><span class="built_in">echo</span> a\*  <span class="comment">#输出：a*</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"I live in <span class="variable">$HOME</span>"</span>  <span class="comment">#输出：I live in /home/zhiqing</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"I live in \$HOME"</span>  <span class="comment">#输出：I live in $HOME</span></span><br></pre></td></tr></table></figure>
<p>还可以使用<code>^V</code>(Ctrl + v)来转义控制字符，如在输入制表符(<code>tab</code>)之前按下<code>^V</code>，即可以把制表符输入参数中。</p>
<blockquote>
<p><code>tab</code>键的功能将在后面提到</p>
</blockquote>
<h3 id="Shell历史-History"><a href="#Shell历史-History" class="headerlink" title="Shell历史(History)"></a>Shell历史(History)</h3><p>通过Shell历史你可以重新执行你之前执行过的命令，常见的一些命令如下：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>history</code></td>
<td>输出执行命令的历史记录</td>
</tr>
<tr>
<td><code>history N</code></td>
<td>输出最近N条记录</td>
</tr>
<tr>
<td><code>history -c</code></td>
<td>清除历史记录</td>
</tr>
<tr>
<td><code>!!</code></td>
<td>重新执行上一条命令</td>
</tr>
<tr>
<td><code>!N</code></td>
<td>重新执行在历史记录中的第N条命令</td>
</tr>
<tr>
<td><code>!-N</code></td>
<td>重新执行最近的第N条记录</td>
</tr>
<tr>
<td><code>!$</code></td>
<td>将上一条命令的最后一个参数作为当前命令的参数，如先执行<code>ls z*</code>，然后执行<code>rm !$</code>，此时的<code>rm !$</code>等同于<code>rm z*</code></td>
</tr>
<tr>
<td><code>!*</code></td>
<td>将上一条命令的所有参数作为当前命令的参数</td>
</tr>
</tbody>
</table>
<h3 id="代码补全"><a href="#代码补全" class="headerlink" title="代码补全"></a>代码补全</h3><p>如果你只记得命令或文件名的前几个字符，你可以通过按<code>tab</code>键来进行自动补全：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/bin</span><br><span class="line">ls un&lt;Tab&gt;&lt;Tab&gt;  </span><br><span class="line"><span class="comment">#系统将会显示出/usr/bin目录下所有以un开头的文件</span></span><br></pre></td></tr></table></figure>
<h2 id="Sehll工作控制"><a href="#Sehll工作控制" class="headerlink" title="Sehll工作控制"></a>Sehll工作控制</h2><ul>
<li><code>jobs</code> 列出工作列表</li>
<li><code>&amp;</code> 在后台运行一个工作</li>
<li><code>^Z</code> 暂停当前前台工作</li>
<li><code>suspend</code> 暂停一个shell</li>
<li><code>fg</code> 恢复一个工作并将其显示到前台</li>
<li><code>bg</code> 让一个已暂停的工作在后台运行</li>
</ul>
<h3 id="jobs"><a href="#jobs" class="headerlink" title="jobs"></a>jobs</h3><p>这是一个内置命令，用于显示当前shell上的工作列表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">jobs</span></span><br><span class="line"><span class="comment">#输出：</span></span><br><span class="line"><span class="comment">#[1]-  Running       emacs myfile &amp;</span></span><br><span class="line"><span class="comment">#[2]+  Stopping      shh exaple.com</span></span><br></pre></td></tr></table></figure>
<p>左边方括号中的整数为工作编号，旁边的加号和减号用于区别是前台工作还是后台工作。</p>
<h3 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h3><p>将<code>&amp;</code>符号放在命令行之后，即可以让该命令在后台运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">emacs myfile &amp;</span><br><span class="line"><span class="comment">#输出 [2] 28090</span></span><br></pre></td></tr></table></figure>
<p>返回的结果包括工作编号(2)和命令的进程号(28090)。</p>
<h3 id="Z"><a href="#Z" class="headerlink" title="^Z"></a>^Z</h3><p>当一个工作在前台运行时，按下<code>^Z</code>会使工作停止暂停，但是状态不变（前台/后台）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sleep 10  <span class="comment">#等待10秒</span></span><br><span class="line">^Z</span><br><span class="line"><span class="comment">#输出：[1]+ Stopped        sleep 10</span></span><br></pre></td></tr></table></figure>
<p>现在你可以输入<code>bg</code>使该工作在后台运行，或者输入<code>fg</code>使该工作恢复到前台运行。当然，你也可以不管该命令而继续执行其他命令。</p>
<h3 id="suspend"><a href="#suspend" class="headerlink" title="suspend"></a>suspend</h3><p><code>suspend</code>是一个内置命令，用于暂停当前shell，就像在当前shell中按<code>^Z</code>。比如当你用<code>sudo</code>命令启动了一个超级用户shell，而你又想返回原shell：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br><span class="line"><span class="comment">#zhiqing</span></span><br><span class="line">sudo bash</span><br><span class="line"><span class="comment">#Password: *******</span></span><br><span class="line">whoami</span><br><span class="line"><span class="comment">#root</span></span><br><span class="line"><span class="built_in">suspend</span></span><br><span class="line"><span class="comment">#[1]+  Stopped        sudo bash</span></span><br><span class="line">whoami</span><br><span class="line"><span class="comment">#zhiqing</span></span><br></pre></td></tr></table></figure>
<h3 id="bg"><a href="#bg" class="headerlink" title="bg"></a>bg</h3><p><code>bg</code>命令可以使一个已暂停的命令在后台继续运行。如果没有参数则运行最近暂停的一个工作。如果需要指定一项明确的工作，则在工作编号前加上百分号传给<code>bg</code>命令作为参数即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bg</span> %2</span><br></pre></td></tr></table></figure>
<p>一些交互型的程序不支持在后台运行，你可以使用<code>fg</code>命令使它们在前台运行。</p>
<h3 id="fg"><a href="#fg" class="headerlink" title="fg"></a>fg</h3><p><code>fg</code>命令可以使一个已暂停的命令在前台继续运行。如果没有参数则通常运行最近暂停的一个工作或在在后台运行的工作。如果需要指定一项明确的工作，则在工作编号前加上百分号传给<code>bg</code>命令作为参数即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fg</span> %2</span><br></pre></td></tr></table></figure>
<h2 id="结束一条命令"><a href="#结束一条命令" class="headerlink" title="结束一条命令"></a>结束一条命令</h2><p>可以使用<code>^C</code>结束一条正在shell前台运行的命令.如果你想结束一条在后台运行的工作，可以使用<code>fg</code>命令使它在前台运行，然后按<code>^C</code>结束该工作。</p>
<blockquote>
<p>另一种选择是使用<code>kill</code>命令。</p>
</blockquote>
<h2 id="退出Shell"><a href="#退出Shell" class="headerlink" title="退出Shell"></a>退出Shell</h2><p>可以使用<code>exit</code>命令或者按<code>^D</code>键退出当前shell。</p>
<h2 id="定制Shell"><a href="#定制Shell" class="headerlink" title="定制Shell"></a>定制Shell</h2><p>你可以定制你自己的shell一边更好的使用或工作。你可以在你的家目录找到并编辑<code>.bash_profile</code>或<code>.bashrc</code>来达到定制shell。它们可以定义变量或别名、运行程序、打印你的星座运势或者是任何你想做的事。</p>


    
    
    
	  <div class="tags">
      <a class="tag-link" href="/tags/Code/">Code</a><a class="tag-link" href="/tags/Linux/">Linux</a><a class="tag-link" href="/tags/Shell/">Shell</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/2016/07/19/linux-pocket-guide-1/">
      《Linux pocket guide》读书笔记之一：文件系统
    </a>
  </h2>
  
  <time>
    Jul 19, 2016
  </time>
  <section class="content">
	  <p>linux中文件系统为树形结构，并用/分隔，例：<code>/home/zhiqing</code>表示根目录下的home目录中的zhiqing文件夹</p>
<ul>
<li>根目录：<code>/</code>（绝对路径以/开头）</li>
<li>家目录：<code>～</code>，例：<code>～/Documents</code>代表<code>/home/username/Documents</code></li>
<li>父目录：<code>..</code>，例：<code>../file</code>代表上一级目录下的file文件</li>
</ul>
<h2 id="家目录"><a href="#家目录" class="headerlink" title="家目录"></a>家目录</h2><p>普通用户的家目录为<code>/home/username</code>，超级用户（root）的家目录为<code>/root</code></p>
<p>常用操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$HOME</span>  <span class="comment">#显示当前用户的家目录</span></span><br><span class="line"><span class="built_in">echo</span> ~  <span class="comment">#同上</span></span><br><span class="line"><span class="built_in">cd</span> ~/Documents  <span class="comment">#进入当前用户家目录中的Documents文件夹</span></span><br><span class="line"><span class="built_in">cd</span> ~zhiqing  <span class="comment">#进入用户zhiqing的家目录</span></span><br></pre></td></tr></table></figure>
<h2 id="系统目录"><a href="#系统目录" class="headerlink" title="系统目录"></a>系统目录</h2><p>系统目录大致分为三部分：<code>/Scope(域)/Category(分类)/Application(应用)</code>。例如：<code>/usr/local/share/emacs</code>，其中<code>usr/local</code>为Scope，<code>share</code>为Category，<code>emacs</code>为Application。</p>
<h3 id="Category（分类）"><a href="#Category（分类）" class="headerlink" title="Category（分类）"></a>Category（分类）</h3><p>分类通常指明了目录的类型，比如目录名为<code>bin</code>则代表该目录下存放的是可执行文件。常见分类如下：</p>
<ul>
<li>程序类<ul>
<li><code>bin</code> 程序的二进制文件（可执行文件）</li>
<li><code>sbin</code> 程序的二进制文件（通常需要root权限）</li>
<li><code>lib</code> 程序的库文件</li>
</ul>
</li>
<li>文档类<ul>
<li><code>doc</code> 文档</li>
<li><code>info</code> emacs的内置文档</li>
<li><code>man</code> 提供给<code>man</code>命令显示的文档</li>
<li><code>share</code> 程序的特殊文件，如安装说明</li>
</ul>
</li>
<li>配置类<ul>
<li><code>etc</code> 系统的配置文件和和各种其他的配置文件</li>
<li><code>init.d</code> linux启动相关的配置文件</li>
<li><code>rc.d</code> linux启动相关配置文件，按级别分类，如：rc1.d,rc2.d,…</li>
</ul>
</li>
<li>编程类<ul>
<li><code>include</code> 头文件</li>
<li><code>src</code> 程序源文件</li>
</ul>
</li>
<li>网站类<ul>
<li><code>cgi-bin</code> 网站运行时的脚本或程序</li>
<li><code>html</code> 网页文件</li>
<li><code>public_html</code> 网页文件，通常存在与用户家目录</li>
<li><code>www</code> 网页文件</li>
</ul>
</li>
<li>硬件类<ul>
<li><code>dev</code> 磁盘或其他硬件的接口设备文件</li>
<li><code>media</code> 挂载点：连接到外部磁盘</li>
<li><code>mnt</code> 挂载点：链接到外部磁盘</li>
</ul>
</li>
<li>运行时类<ul>
<li><code>lock</code> 锁文件</li>
<li><code>log</code> 日志文件，包括错误、警告和提示信息</li>
<li><code>run</code> PID文件</li>
<li><code>tmp</code> 零时文件</li>
<li><code>proc</code> 操作系统的状态</li>
</ul>
</li>
</ul>
<h3 id="Scope（域）"><a href="#Scope（域）" class="headerlink" title="Scope（域）"></a>Scope（域）</h3><p>域通常包含了目录的描述</p>
<ul>
<li><code>/</code> linux的系统文件</li>
<li><code>/usr</code> 更多的linux系统文件</li>
<li><code>/usr/local</code> 为组织或个人开发的本地化的系统文件</li>
<li><code>/usr/games</code> 游戏</li>
</ul>
<p>一个分类会出现在多个域中，例如：<code>/lib</code>、<code>/usr/lib</code>、<code>/usr/local/lib</code>和<code>/usr/games/lib</code>可能会同时存在。</p>
<h3 id="Application（应用）"><a href="#Application（应用）" class="headerlink" title="Application（应用）"></a>Application（应用）</h3><p>应用部分通常为程序名。系统目录中，在Scope和Category之后，每个应用都会有一个自己的子文件夹（如：<code>/usr/local/doc/myprogram</code>）用于存放自己需要的文件。</p>
<h2 id="操作系统目录"><a href="#操作系统目录" class="headerlink" title="操作系统目录"></a>操作系统目录</h2><p>操作系统目录是保证系统内核运行的目录，最少要包含以下几个目录：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/boot</code></td>
<td>存放系统启动相关的文件，Linux内核(kernel)一般存放在<code>/boot/vmlinuz</code>或类似的目录中。</td>
</tr>
<tr>
<td><code>/lost+found</code></td>
<td>用于磁盘修复工具恢复已损坏文件</td>
</tr>
<tr>
<td><code>/proc</code></td>
<td>系统中正在运行的进程的描述</td>
</tr>
</tbody>
</table>
<p><code>/proc</code> 目录中的文件显示的是正在运行的内核和一些特殊的配置信息。它们的大小总是为0、修改时间为现在，并且权限为只读(-r–r–r–)。常见文件如下：</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/proc/ioports</code></td>
<td>计算机中IO设备的列表</td>
</tr>
<tr>
<td><code>/proc/cpuinfo</code></td>
<td>CPU的信息</td>
</tr>
<tr>
<td><code>/proc/version</code></td>
<td>操作系统的版本，同<code>uname</code>命令显示的内容</td>
</tr>
<tr>
<td><code>/proc/uptime</code></td>
<td>系统运行时间</td>
</tr>
</tbody>
</table>
<h2 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h2><p>linux中的权限包括：读(read)、写(write)、执行(execute)</p>
<ul>
<li>读：读取文件内容、显示目录中的文件</li>
<li>写：修改或删除文件、创建或删除目录</li>
<li>执行：运行脚本或二进制文件、进入目录</li>
</ul>
<p>执行<code>ls -l file</code>命令，每条记录前10个字符即为该文件的权限。表现形式类似：<code>-rwxr-x---</code>。解释如下：</p>
<table>
<thead>
<tr>
<th>位数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>文件类型（-为文件，d为目录，l为链接，p为管道，c为字符设备，b为块设备）</td>
</tr>
<tr>
<td>2-4</td>
<td>文件所有者的读、写、执行权限（为-则表示没有该权限）</td>
</tr>
<tr>
<td>5-7</td>
<td>文件所在组的读、写、执行权限</td>
</tr>
<tr>
<td>8-10</td>
<td>其他用户的读、写、执行权限</td>
</tr>
</tbody>
</table>
<p>所以<code>-rwxr-x---</code>表示<code>file</code>是一个文件，该文件的所有者可以读、写、执行，该文件所所在组的用户可以读和执行，其他用户不能读、写和执行。</p>


    
    
    
	  <div class="tags">
      <a class="tag-link" href="/tags/Code/">Code</a><a class="tag-link" href="/tags/Linux/">Linux</a><a class="tag-link" href="/tags/《Linux-pocket-guide》/">《Linux pocket guide》</a><a class="tag-link" href="/tags/读书笔记/">读书笔记</a>
	  </div>
    

  </section>
</article>
  
</section>


  <nav id="page-nav">
    
    <a class="prev" rel="prev" href="/">
      <span class="icon icon-chevron-left"></span>
      <span class="text">Previous</span>
    </a>
    
    
  </nav>
  

      <script>setLoadingBarProgress(60);</script>
    </main>
    
    <footer id="footer" class="clearfix">
  
  
	<div class="search">
	  <form name="searchform" id="searchform" class="u-search-form">
	    <input type="text" id="searchinput" class="u-search-input" placeholder="Looking for something?" />
	    <button type="submit" id="u-search-btn-submit" class="u-search-btn-submit">
	      <span class="icon icon-search"></span>
	    </button>
	  </form>
	</div>
	

	<div class="social-wrapper">
  	
      
        <a href="mailto:i@zhiqing.info" class="social email"
          target="_blank" rel="external">
          <span class="icon icon-email"></span>
        </a>
      
        <a href="https://github.com/zhiqing-lee" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="https://twitter.com/zhiqing_hello" class="social twitter"
          target="_blank" rel="external">
          <span class="icon icon-twitter"></span>
        </a>
      
        <a href="/atom.xml" class="social rss"
          target="_blank" rel="external">
          <span class="icon icon-rss"></span>
        </a>
      
    
  </div>
  
  <div>Theme <span class="codename">Typescript</span> designed by <a href="http://rakugaki.me/" target="_blank">Art Chen</a>.</div>
  <div>&copy; <a href="/">Zhiqing&#39;s Blog</a></div>
  
</footer>


    <script>setLoadingBarProgress(80);</script>
    
  </div>

  
<script>
  var disqus_shortname = 'zhiqngs-blog';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>




<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script>window.jQuery || document.write('<script src="/js/jquery.min.js"><\/script>')</script>

<script src="/js/jquery.fitvids.js"></script>
<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "hexo";
</script>
<script src="/js/search.js"></script>
<script src="/js/app.js"></script>


  <script>setLoadingBarProgress(100);</script>
  
</body>
</html>
