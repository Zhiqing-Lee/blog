{"pages":[{"title":"","permalink":"http://blog.zhiqing.info/404.html","text":""},{"title":"分类","permalink":"http://blog.zhiqing.info/categories/index.html","text":""},{"title":"关于我","permalink":"http://blog.zhiqing.info/about/index.html","text":"一个沉迷于写Hello world的码农"},{"title":"标签","permalink":"http://blog.zhiqing.info/tags/index.html","text":""}],"posts":[{"title":"使用Flex布局实现一个聊天界面 (倒叙滚动)","permalink":"http://blog.zhiqing.info/2018/03/29/realize-a-chat-view-with-flex/","text":"临近毕业，马上就要离开生活了四年的大学。却被找工作、毕业设计等事情困扰着的我流下了没有技术的泪水T_T 毕业设计选题选了一个《基于Web的IM应用的设计与实现》，技术栈打算使用 Vue + Java + WebSocket ，不过后面可能会把Java换成Nodejs。 在写前端页面时，为了写得爽，全面使用了Flex布局，也就不考虑兼容IE什么的了。写到聊天的界面时，发现Flex布局的 flex-direction: column-reverse; 简直是为这种情况量身定制的。上拉读取聊天记录时直接按时间倒叙查询，然后向消息数组里push就是了，逻辑很明确。 实现了以后更是发现使用 flex-direction: column-reverse; 后默认显示的是列表的底部，这就更完美了，都不用手动滚动到底部了。 一切都还很美好，直到我一时兴起用 Edge 打开了我的毕业设计，看看有没有什么兼容性问题时。发现这个聊天界面在 Edge 上完全是不能滚动的！！！然后默默地打开了 Firefox ，发现问题一样的存在-_-！ 马上 Google 搜索一下，发现不止是我一个人遇到过这样的问题 (果然我不是天选之人， Bug之下人人平等)。 据搜索结果里的人所说，这在Firefox中是一个 已知问题 。这下没办法了，必须要解决这个问题。本来就已经放弃IE支持，不可能再放弃Edge和Firefox的支持吧，那样的话要这个应用还有什么用。 搜索结果里的解决方案是在消息列表的外面再套一层容器，既然消息列表不能滚动，那就让它外面的容器可滚动。代码大致如下： 12345678910&lt;!-- in html --&gt;&lt;div class=\"container\"&gt; &lt;div class=\"messages\"&gt; &lt;div class=\"message\"&gt; Message 1 &lt;/div&gt; &lt;div class=\"message\"&gt; Message 2 &lt;/div&gt; &lt;div class=\"message\"&gt; Message 3 &lt;/div&gt; &lt;div class=\"message\"&gt; Message 4 &lt;/div&gt; &lt;div class=\"message\"&gt; Message 5 &lt;/div&gt; &lt;div&gt;&lt;/div&gt; 12345678910111213141516/* in style */.container &#123; overflow-y: auto; height: 100px; width: 100px;&#125;.messages &#123; display: flex; flex-direction: column-reverse;&#125;.message &#123; flex: 0 0 50px; backgorund: red;&#125; 这样做是都可以滚动了，但是像QQ、微信这样，聊天界面都是最后一条消息在最下面，默认展示的也是最后一条消息,及滚动方式是从底部向上滚动。用这种实现方式就必须在页面加载完成（对应Vue组件的是数据加载完成并绑定到页面上）后手动地滚动该容器到底部了。代码如下： 12345// in scriptwindow.onload = () =&gt; &#123; const container = document.querySelector('.container'); container.scrollTop = container.scrollHeight;&#125; 以上代码的展示效果可以 点击这里 查看 至此，就实现了一个类似微信聊天界面的页面（虽说有点简陋）。感兴趣的可以查看我的 毕业设计 里的实现，效果如下，看起来还是要高大上一点的。 不过实现了过后再想想，用 flex-direction: column-reverse; 方式和 flex-direction: column; 方式实现区别并不大。无非是在添加数据时用 push 方法还是 unshift 方法。"},{"title":"通过Systemd让SSR开机自启动","permalink":"http://blog.zhiqing.info/2017/12/25/start-up-ssr-with-systemd/","text":"果然，之前让项目支持部署到Docker这个决定是很正确的。这不，又把系统从Windows换成了Linux。而原因竟然是我的笔记本在Windows下玩游戏会无限崩溃，而在Linux下不会！！！用Linux是为了玩游戏我恐怕还是第一人吧!既然装Linux是为了玩游戏，那么也没有必要双系统了，毕竟个人感觉Linux下搞开发还是比Windows爽很多的。不过还是吐槽一下Linux上玩游戏的确还是没有Windows上流畅，可能是因为显卡驱动程序太旧了吧。 装上新系统第一件事当时然是解决科学上网。之前一直是用的SS，Linux下也有QT版的GUI客户端，用着还不错。可是在之前用Windows的时间里，SS被封了。于是换成了魔改版的SSR，Windows下也有GUI客户端，用着还不错。可是一换到Linux下，SSR好像没有GUI客户端。只好用CLI客户端，反正又这程序开着基本上看不着，开机时启动、关机时关闭。那么问题来了，不可能每次开机时手动开启吧，得让它开机时自启动啊。 之前试过在 /etc/profile 文件中添加命令以达到自启动的目的，但是会出现一些小问题。使用 source 命令时会再启动一次该程序。SSR的服务端是使用的Supervisor来管理的，但是又不想在电脑中多装软件。于是想到还有个Systemd。 好了，说了这么多废话开始正题吧。 首先在 /etc/systemd/system 目录中新建名为 ssr.service 的配置文件，并写入以下内容: 1234567[Unit]Description=Started SSR ServiceAfter=network.targetWants=network.target[Service]ExecStart=/usr/bin/python /home/zhiqing/App/shadowsocksr/shadowsocks/local.py -c /etc/ssr.json 自行修改其中ExecStart项的值，注意必须使用绝对目录写法。 这样就在Systemd中添加了一个服务。接着在命令行中输入 systemctl enable ssr 就可以让该服务启用开机自启。使用 systemctl start ssr 可立即启动服务。使用 systemctl stop ssr 可停止该服务。（不过这里没有写停止服务的命令，应该是不能用的）"},{"title":"在Java开发中使用Docker","permalink":"http://blog.zhiqing.info/2017/11/28/develop-java-web-with-docker/","text":"上一篇博客中提到，最近在写一个Java Web应用，因为某些原因换了开发环境，然后折腾了半天。于是就想起来使用Docker来搭建开发环境，妈妈以后就再也不用担心我开发中途换环境了！搭建过程还是比较顺利的，现在来记录一下如何将基于Maven的Java项目部署到Docker。如果不是基于Maven的项目，可参考该博客进行相应的修改。 1.安装Docker这一步不用多说什么，直接进入官网按照提示安装即可。Linux 需要单独安装 Docker Compose 。 Mac OS 和 Windows版的Docker安装包里已经内置了 Docker Compose， 不用单独安装。 2.添加并修改配置文件在应用根目录里添加 config 目录，然后复制Tomcat的 Server.xml 配置文件到该目录。然后根据自己的需求修改该配置文件。 因为本人习惯于将应用部署到Tomcat根目录，所以需要修改Tomcat配置文件。而Docker容器里直接修改配置文件不是很方便，所以新建一个配置文件用于替换容器里的配置文件。如使用默认配置文件即可跳过这步。 3. 编写 Dockerfile 文件在应用根目录中添加 Dockerfile 文件，并写入一下内容： 12345678910111213141516FROM tomcat:8.0-jre8-alpine# 删除Tomcat默认根目录，可根据自己需求保留或删除RUN rm -rf /usr/local/tomcat/webapps/ROOT/# 替换Tomcat配置文件，可根据自己需求修改或删除COPY ./config/server.xml /usr/local/tomcat/conf/server.xml# 挂载应用目录，根据自己需求修改，需与Tomcat配置文件一致VOLUME /usr/local/tomcat/webapps/forus/# 暴露8080端口EXPOSE 8080# 运行Tomcat，并启用远程调试CMD [\"catalina.sh\", \"jpda\", \"run\"] 在应用根目录下添加 .dockerignore 文件。该文件与 .gitignore 类似，用于避免将某些文件添加到创建Docker镜像时的上下文。在其中添加除了 config 目录之外的其他目录及文件： 123src/.idea/target/ 可以将 config 目录及 Dockerfile 添加到另一个目录中来避免 .dockerignore 文件 4. 编写 docker-compose.yml 文件因为自己的项目用到了Mysql和Redis，需要运行多个服务容器。所以用了Docker Compose 来管理这些服务。 1234567891011121314151617181920212223242526272829version: \"2.3\"services: mysql: image: mysql expose: - \"3306\" # Mysql 服务端口 environment: - MYSQL_ROOT_PASSWORD=123456 # Mysql root 用户密码 redis: image: redis:alpine expose: - \"6379\" forus: build: . links: - mysql - redis environment: - spring.profiles.active=test # 激活 Spring 的 Profile - JPDA_ADDRESS=0.0.0.0:8000 # 远程调试地址 volumes: - ./target/forus/:/usr/local/tomcat/webapps/forus/ expose: - \"8080\" ports: - \"8080:8080\" # 应用端口映射 - \"8000:8000\" # 远程调试端口映射 5. 运行/调试运行12345671. 在应用根目录下运行 `mvn war:exploded` 命令编译项目。2. 运行 `docker-compose up` 命令构建镜像并运行相应服务。3. 在浏览器中打开 `localhost:8080` 即可访问该应用。4. 在应用根目录下运行 `docker-compose down` 命令可停止相应服务并删除相关容器和镜像。 调试1通过远程调试的方式连接到 `localhost:8000&apos; 可进行调试。"},{"title":"部署Java Web应用到Tomcat的根目录","permalink":"http://blog.zhiqing.info/2017/11/21/deploy-java-web-to-tomcat-root/","text":"之前写Java Web应用都是用的Spring Boot，直接生成 jar 文件进行执行，部署方面的一些细节Spring Boot基本都帮我搞定了。最近再写一个论坛程序时，突然就不想用Spring Boot了。最后采用了XML方式配置了SSM环境。顺便熟悉一下Spring相关配置文件的细节（学了以后基本没用过，已经忘得差不多了）。 因为某些原因，中途开发环境从Ubuntu转到了Windows。转到Windows后又因跟校实习中断了一段时间。回校后运行项目时发现Redis服务打不开了。于是就想着干脆直接上Docker算了，免得下次换开发环境又出各种问题。 因为开发时一直用的IDEA，配置好Tomcat后默认是部署到根目录的，使用Spring Boot时也是在根目录。所以开发时基本都是用的绝对路径或相对路径，没有使用上下文路径的习惯。如果直接复制war包多出来一个上下文怕是要出问题。 于是Google了一下如何将war包部署到Tomcat根目录，对比了多个博客，终于还是弄出来了。 这次先记录一下部署到Tomcat，下次再记录部署到Docker。 1.重新指定目录 新建一个目录用于存放应用的目录，并将war包放入其中。这种方法不会破坏Tomcat默认目录。 和上面一样在配置文件 $CATALINA_HOME/conf/server.xml 中找到如下结点 ($CATALINA_HOME为Tomcat安装目录) 12345&lt;Host name=\"localhost\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"false\"&gt; ...&lt;/Host&gt; 修改该该结点的 appBase 值为上面创建的目录，如该目录位于 $CATALINA_HOME 中，可以直接写相对路径。 在 2 中的结点里添加一个子结点： 1234567&lt;Host name=\"localhost\" appBase=\"folder\" unpackWARs=\"true\" autoDeploy=\"false\"&gt; &lt;Context path=\"\" docBase=\"appname\" debug=\"0\" /&gt; ...&lt;/Host&gt; 其中 appname 为应用名，及放入 folder 中的war包名。 启动Tomcat后，访问即可通过指定的地址及端口(http://localhost:8080)的根目录访问到刚刚部署的应用。 2.替换默认文件 移动 $CATALINA_HOME/webapps/ROOT 目录到 $CATALINA_HOME/webapps/ROOT_BAK 这一步我在网上搜到的是删除 ROOT 目录里的所有内容，但我测试时必须要删除整个目录才生效。应该和Tomcat版本有关。 在Tomcat配置文件 $CATALINA_HOME/conf/server.xml 中找到如下代码： 12345&lt;Host name=\"localhost\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"false\"&gt; ...&lt;/Host&gt; 在 2 中的结点里添加一个子结点： 1234567&lt;Host name=\"localhost\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"false\"&gt; &lt;Context path=\"\" docBase=\"appname\" debug=\"0\" /&gt; ...&lt;/Host&gt; 这样部署会破坏Tomcat的默认主页 3.总结虽然说写的是两种方式，但其原理并没有区别。只是一个使用了Tomcat默认的目录，一个没使用而已。重要的是理解其中几个属性的用法。 appBase 的值为存放app的目录，Host 的子结点 Context 中的 docBase 的值是相对于它的。该值可以使用绝对目录或相对目录。使用相对目录时是相对于 $CATALINA_HOME 目录的。 path 配置该上下文的路径，如为空则为根目录。 docBase 的值为具体应用的路径，可以设置为war包或者一个目录。可以使用相对路径或绝对路径。相对路径相对于 appBase 的值。"},{"title":"Android学习笔记：volley初试","permalink":"http://blog.zhiqing.info/2016/07/24/android-learning-volley/","text":"Volley是一个Android的HTTP库，用于方便地执行网络操作。 Volley不适用与下载很大的文件。 开始使用Clone 仓库源码到本地(需翻墙)：1git clone https://android.googlesource.com/platform/frameworks/volley 导入Volley 在Android Studio中选择File -&gt; New -&gt; Import Module 在弹出的对话框中的Source directory栏中选择刚刚Clone到本地的文件夹 在Module name中输入模块名（默认为:volley) 添加依赖 代码方式：在build.gradle (Module: app)文件中的dependencies部分加入compile project(&#39;:volley&#39;)(其中:volley为导入模块时输入的名字)： 123456dependencies &#123; compile fileTree(include: ['*.jar'], dir: 'libs') testCompile 'junit:junit:4.12' compile 'com.android.support:appcompat-v7:23.4.0' compile project(':volley')&#125; 在 Android Studio 中选择 File -&gt; Project Structure，在Modules中选中app，然后选择Dependencies，单击右边绿色的+，选择Module dependency，选择刚刚导入的模块(:volley)。 添加INTERNET权限在manifest文件中添加如下代码： 1&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt; 请求队列使用 Volley 的方式是，创建一个 RequestQueue 并传递 Request 对象给它。RequestQueue 管理用来执行网络操作的工作线程、从缓存中读取数据、写数据到缓存、并解析 Http 的响应内容。Volley 会把解析完的响应数据分发给主线程。 使用Volley.newRequestQueueVolley 提供了一个便捷方法 Volley.newRequestQueue() 来创建 RequestQueue： 1234567891011121314151617181920212223TextView mTextView = (TextView) findViewById(R.id.text_view);// 创建一个RequestQueueRequestQueue queue = Volley.newRequestQueue(this);String url =\"http://baidu.com\";// 创建一个StringRequest，请求响应结果为StringStringRequest stringRequest = new StringRequest(Request.Method.GET, url, new Response.Listener() &#123; @Override public void onResponse(String response) &#123; // 显示响应结果到一个TextView mTextView.setText(response); &#125;&#125;, new Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; //当遇到错误时显示'Error!' mTextView.setText(\"Error!\"); &#125;&#125;);// 添加该请求到请求队列queue.add(stringRequest); 创建自定义请求队列设置网络和缓存RequestQueue需要两部分来支持工作：网络(Network)和缓存(Cache)： 1234567891011121314151617181920212223242526272829303132RequestQueue mRequestQueue;// 创建一个缓存Cache cache = new DiskBasedCache(getCacheDir(), 1024 * 1024);// 设置网络使用HttpURLConnection类作为HTTP客户端。Network network = new BasicNetwork(new HurlStack());// 用创建的缓存和网络来实例化一个请求队列mRequestQueue = new RequestQueue(cache, network);// 开启队列mRequestQueue.start();String url =\"http://www.example.com\";StringRequest stringRequest = new StringRequest(Request.Method.GET, url, new Response.Listener&lt;String&gt;() &#123; @Override public void onResponse(String response) &#123; // Do something with the response &#125;&#125;, new Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; // Handle error &#125;&#125;);// 添加请求到请求队列mRequestQueue.add(stringRequest); 使用单例模式一个提供了RequestQueue和ImageLoader的单例类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MySingleton &#123; private static MySingleton mInstance; private RequestQueue mRequestQueue; private ImageLoader mImageLoader; private static Context mCtx; private MySingleton(Context context) &#123; mCtx = context; mRequestQueue = getRequestQueue(); mImageLoader = new ImageLoader(mRequestQueue, new ImageLoader.ImageCache() &#123; private final LruCache&lt;String, Bitmap&gt; cache = new LruCache&lt;String, Bitmap&gt;(20); @Override public Bitmap getBitmap(String url) &#123; return cache.get(url); &#125; @Override public void putBitmap(String url, Bitmap bitmap) &#123; cache.put(url, bitmap); &#125; &#125;); &#125; public static synchronized MySingleton getInstance(Context context) &#123; if (mInstance == null) &#123; mInstance = new MySingleton(context); &#125; return mInstance; &#125; public RequestQueue getRequestQueue() &#123; if (mRequestQueue == null) &#123; // getApplicationContext() is key, it keeps you from leaking the // Activity or BroadcastReceiver if someone passes one in. mRequestQueue = Volley.newRequestQueue(mCtx.getApplicationContext()); &#125; return mRequestQueue; &#125; public &lt;T&gt; void addToRequestQueue(Request&lt;T&gt; req) &#123; getRequestQueue().add(req); &#125; public ImageLoader getImageLoader() &#123; return mImageLoader; &#125;&#125; 一个单例类的使用例子： 123456// 获取一个请求队列RequestQueue queue = MySingleton.getInstance(this.getApplicationContext()). getRequestQueue();// 添加一个请求到请求队列MySingleton.getInstance(this).addToRequestQueue(stringRequest); 取消请求 为Request设置标签： 1234567public static final String TAG = \"MyTag\";// 为请求设置标签stringRequest.setTag(TAG);// 添加请求到请求队列mRequestQueue.add(stringRequest); 在Activiy的onStop()方法中取消包含该标签的请求： 1234567@Overrideprotected void onStop () &#123; super.onStop(); if (mRequestQueue != null) &#123; mRequestQueue.cancelAll(TAG); &#125;&#125; 请求Request生命周期 创建标准请求Volley 的几种种常用的请求： StringRequest: 指定一个URL并且接收字符串类型的响应数据 ImageRequset: 指定一个URL并且接收图片类型的响应数据 JsonObjectRequest和JsonArrayRequest: 指定一个URL并且接收Json对象(数组)类型的响应数据 请求图片使用ImageRequset12345678910111213141516171819ImageView mImageView;String url = \"http://zhiqing.info/images/logo.png\";mImageView = (ImageView) findViewById(R.id.image_view);// 根据URL请求图片并显示到用户界面ImageRequest request = new ImageRequest(url, new Response.Listener() &#123; @Override public void onResponse(Bitmap bitmap) &#123; mImageView.setImageBitmap(bitmap); &#125; &#125;, 0, 0, null, new Response.ErrorListener() &#123; public void onErrorResponse(VolleyError error) &#123; mImageView.setImageResource(R.drawable.image_load_error); &#125; &#125;);// 通过单例类取得RequestQueue并将图片请求添加到RequestQueueMySingleton.getInstance(this).addToRequestQueue(request); 使用 ImageLoader 和 NetworkImageView使用ImageLoader显示图片： 1234567891011ImageLoader mImageLoader;ImageView mImageView;// The URL for the image that is being loaded.private static final String IMAGE_URL = \"http://developer.android.com/images/training/system-ui.png\";mImageView = (ImageView) findViewById(R.id.regularImageView);// Get the ImageLoader through your singleton class.mImageLoader = MySingleton.getInstance(this).getImageLoader();mImageLoader.get(IMAGE_URL, ImageLoader.getImageListener(mImageView, R.drawable.def_image, R.drawable.err_image)); 使用NetworkImageView： 12345&lt;com.android.volley.toolbox.NetworkImageView android:id=\"@+id/networkImageView\" android:layout_width=\"150dp\" android:layout_height=\"170dp\" android:layout_centerHorizontal=\"true\" /&gt; 1234567891011121314ImageLoader mImageLoader;NetworkImageView mNetworkImageView;private static final String IMAGE_URL = \"http://developer.android.com/images/training/system-ui.png\";// Get the NetworkImageView that will display the image.mNetworkImageView = (NetworkImageView) findViewById(R.id.networkImageView);// Get the ImageLoader through your singleton class.mImageLoader = MySingleton.getInstance(this).getImageLoader();// Set the URL of the image that should be loaded into this view, and// specify the ImageLoader that will be used to make the request.mNetworkImageView.setImageUrl(IMAGE_URL, mImageLoader); 请求Json1234567891011121314151617181920212223TextView mTxtDisplay;ImageView mImageView;mTxtDisplay = (TextView) findViewById(R.id.txtDisplay);String url = \"http://my-json-feed\";JsonObjectRequest jsObjRequest = new JsonObjectRequest (Request.Method.GET, url, null, new Response.Listener() &#123; @Override public void onResponse(JSONObject response) &#123; mTxtDisplay.setText(\"Response: \" + response.toString()); &#125;&#125;, new Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; // TODO Auto-generated method stub &#125;&#125;);// Access the RequestQueue through your singleton class.MySingleton.getInstance(this).addToRequestQueue(jsObjRequest);"},{"title":"《Linux pocket guide》读书笔记之二：Shell特性","permalink":"http://blog.zhiqing.info/2016/07/20/linux-pocket-guide-2/","text":"使用Linux操作系统时，通常是在一个叫Shell的东西里输入命令然后敲入回车，从而让Linux执行相应的程序。比如在Shell中输入who然后敲入回车，系统将会输出有哪些用户在什么地方登录了该计算机。 | 为管道符，用于链接两条命令，作用是将第一条命令的输出作为第二条命令的输入。如who | wc -l将会显示当前有多少用户登录了该计算机（wc -l命令的功能为显示输入数据的行数）。 echo $SHELL 可以显示shell的类型，大多数linux发型版都默认为bash(the Bourne-Again Shell)，输出为/bin/bash。 exit 退出当前shell Shell命令对应的程序当你输入一条命令时，实际上是调用了一个linux程序或者是一条内置的命令。可以使用type命令显示一个命令的类型或程序的位置： 12type who #输出: who is /usr/bin/whotype cd #输出: cd is a shell builtin bash的特点通配符通配符是用来代替一个或多个字符的符号，例如：a*的意思是所有以字符a开头的文件。如果在shell中输入ls a*会显示当前文件夹下所有以a开头的文件。和输入ls apple applet ada效果相同。 ls命令并不知道你使用了通配符，通配符是由shell处理的，所以原则上每个命令都能使用通配符。 点文件： 点文件是指文件名以英文句点开头的文件，如：.profile。这种文件在很多程序中默认是不可见的，也被称为隐藏文件 ls 命令默认不显示点文件，除非加上-a选项 shell的通配符不匹配点文件 通配符： * 零个或多个字符 ? 单个字符 [set] 给定集合中的任意字符，如:[aeiouAEIOU]将匹配任意一个元音字母，也可以给定一个范围，如:[A-Z]将匹配任意一个大写字母 [^set] 匹配任意一个不在给定集合中的字符，如[^0-9]就爱那个匹配一个不是数字的字符 [!set] 同[^set] 大括号匹配和通配符类似，大括号里的表达式将会被分为多个参数传给命令： {X,YY,ZZZ} shell会分别把X、YY、ZZZ传给命令行，例如： 12echo sand&#123;X,YY,ZZZ&#125;wich #输出：sandXwich sandYYwich sandZZZwich Shell变量你可以定义变量并赋值： 1MYVAR=3 通过美元符号加变量名可以取出变量的值： 1echo $MYVAR #输出： 3 在启动shell之前系统通常会帮你定义的一些变量： 变量 含义 DISPLAY 显示器名称 HOME 家目录地址，如：/home/zhiqing LOGNAME 登录的用户名，如：zhiqing OLDPWD 上一个cd命令执行之前的目录 PATH shell搜索路径，用:分隔的目录 PWD 当前目录 SHELL shell的路径，如：/bin/bash TERM 终端的类型，如：xterm USER 当前登录的用户名 变量的作用域一般是默认是当前Shell，如果想让其他shell和程序也能调用该变量，需使用export命令： 123MYVAR=3export MYVAR export MYVAR2=3 #功能和上两行一样 这样的变量叫做环境变量(environment variable),通过printenv命令可以输出环境变量： 1234printenv #输出所有环境变量printenv HOME #输出单个环境变量，输出：`/home/zhiqing`HOME=/home/tom printenv HOME #输出:`/home/tom`printenv HOME #输出：`/home/zhiqing` 如上所示，如需临时改变环境变量的值，可在命令前加上变量=值。 搜索路径(PATH)Linux系统中的程序存放在各种各样的目录中，如/bin、/usr/bin、/opt/java/jdk/bin。为了方便shell能够正确找到该程序，shell提供了PATH环境变量： 1echo $PATH #输出：`/usr/local/bin:/bin:/usr/bin` 如上所示，PATH中的值是用:分隔的多个目录。shell执行程序时会在这些目录中一个一个地查找，找到了便运行该程序，否则提示bash: who: command not found。 你也可以添加自己的程序目录到环境变量： 123PATH=$PATH:/home/zhiqing/progecho $PATH #输出:`/usr/local/bin:/bin:/usr/bin:/homae/zhiqing/prog` 这样只会影响当前shell，在~/.bash_profile文件中设置PATH变量可使以后每次开启Shell自动设置。 别名(Aliases)可以使用内置的alias命令为长命令创建别名以方便记忆和输入： 12alias ll='ls -lG'll #此时`ll`与`ls -lG`的输出相同 在~/.bash_profile中定义别名，可以使以后登录后直接使用你定义的别名。 输入/输出重定向Shell可以把srandard input(标准输入)、srandard output(标准输出)、srandard error(标准错误输出)重定向到文件或从文件重定向： 123456789command &lt; infile #重定向文件到标准输入command &gt; outfile #重定向标准输出到一个文件（创建新文件/覆盖就文件）command &gt;&gt; outfile #重定向标准输出到一个文件（追加到文件之后）command 2&gt; errorfile #重定向标准错误输出到文件command &gt; outfile 2&gt; errorfile #分别重定向标准输出和标准错误输出到不同的文件command &gt;&amp; outfilecommand &amp;&gt; outfile#以上两个均为重定向标准输出和标准错误输出到一个共同的文件 管道(Pipes)使用管道(|)你可以重定向一条命令的标准输出到另一条命令的标准输入： 12ls | wc -l #输出当前目录下的文件个数ls | wc -l | cowsay #让一只母牛说出当前目录下的文件个数 子过程与管道类似，使用子过程&lt;(command)可以把一条命令的输出以文件的形式重定向到另一条命令： 12cat &lt;(ls | wc -l | cowsay)#让一只母牛说出当前目录下的文件个数，但`cat`命令接收的参数为文件 执行多条命令用;分隔一行内的多条命令，可以使这些命令按次序依次执行： 12command1 ; command2 ; command3#依次执行command1, command2, command3 用&amp;&amp;分隔一行内的多条命令，可以使前面的所有命令均执行成功再执行后面的命令： 123command1 &amp;&amp; command2 &amp;&amp; command3#先执行command1，如成功则执行command2，否则退出#command1和command2均执行成功才会执行command3 用||分隔一行内的多条命令，可以使前面的所有命令中只要有一条执行成功则执行后面的命令： 123command1 || command2 || command3#先执行command1，如成功则执行command2，否则退出#command1和command2只要有一条执行成功会执行command3 引用通常一条命令的参数中如过有空格，则该参数会被分为多个参数传递给命令。如需传递包含空格的参数，需使用单引号‘或双引号&quot;引起来。双引号中的字符串会被解析而单引号不会： 1234echo 'HOME变量的值为$HOME'#输出：HOME变量的值为$HOMEecho \"HOME变量的值为$HOME\"#输出：HOME变量的值为/home/zhiqing 一对反引号(`)中可以包含一条命令，该处的内容会被命令的输出所代替： 12date +%Y #输出当前年：2016echo This year is `date +%Y` #输出：This year is 2016-07 $(command)有同样的功能，但是使用$(command)更好,因为它可以嵌套： 123echo This year is $(date +%Y) #输出：This year is 2016echo This year is $(expr $(date +%Y) + 1)#输出：This year is 2017 转义有时候你想在参数中包含已被Shell使用的特殊符号，如*、$，这时可以使用转义符\\： 1234echo a* #输出：apple applet appecho a\\* #输出：a*echo \"I live in $HOME\" #输出：I live in /home/zhiqingecho \"I live in \\$HOME\" #输出：I live in $HOME 还可以使用^V(Ctrl + v)来转义控制字符，如在输入制表符(tab)之前按下^V，即可以把制表符输入参数中。 tab键的功能将在后面提到 Shell历史(History)通过Shell历史你可以重新执行你之前执行过的命令，常见的一些命令如下： 命令 含义 history 输出执行命令的历史记录 history N 输出最近N条记录 history -c 清除历史记录 !! 重新执行上一条命令 !N 重新执行在历史记录中的第N条命令 !-N 重新执行最近的第N条记录 !$ 将上一条命令的最后一个参数作为当前命令的参数，如先执行ls z*，然后执行rm !$，此时的rm !$等同于rm z* !* 将上一条命令的所有参数作为当前命令的参数 代码补全如果你只记得命令或文件名的前几个字符，你可以通过按tab键来进行自动补全： 123cd /usr/binls un&lt;Tab&gt;&lt;Tab&gt; #系统将会显示出/usr/bin目录下所有以un开头的文件 Sehll工作控制 jobs 列出工作列表 &amp; 在后台运行一个工作 ^Z 暂停当前前台工作 suspend 暂停一个shell fg 恢复一个工作并将其显示到前台 bg 让一个已暂停的工作在后台运行 jobs这是一个内置命令，用于显示当前shell上的工作列表： 1234jobs#输出：#[1]- Running emacs myfile &amp;#[2]+ Stopping shh exaple.com 左边方括号中的整数为工作编号，旁边的加号和减号用于区别是前台工作还是后台工作。 &amp;将&amp;符号放在命令行之后，即可以让该命令在后台运行： 12emacs myfile &amp;#输出 [2] 28090 返回的结果包括工作编号(2)和命令的进程号(28090)。 ^Z当一个工作在前台运行时，按下^Z会使工作停止暂停，但是状态不变（前台/后台）： 123sleep 10 #等待10秒^Z#输出：[1]+ Stopped sleep 10 现在你可以输入bg使该工作在后台运行，或者输入fg使该工作恢复到前台运行。当然，你也可以不管该命令而继续执行其他命令。 suspendsuspend是一个内置命令，用于暂停当前shell，就像在当前shell中按^Z。比如当你用sudo命令启动了一个超级用户shell，而你又想返回原shell： 12345678910whoami#zhiqingsudo bash#Password: *******whoami#rootsuspend#[1]+ Stopped sudo bashwhoami#zhiqing bgbg命令可以使一个已暂停的命令在后台继续运行。如果没有参数则运行最近暂停的一个工作。如果需要指定一项明确的工作，则在工作编号前加上百分号传给bg命令作为参数即可： 1bg %2 一些交互型的程序不支持在后台运行，你可以使用fg命令使它们在前台运行。 fgfg命令可以使一个已暂停的命令在前台继续运行。如果没有参数则通常运行最近暂停的一个工作或在在后台运行的工作。如果需要指定一项明确的工作，则在工作编号前加上百分号传给bg命令作为参数即可： 1fg %2 结束一条命令可以使用^C结束一条正在shell前台运行的命令.如果你想结束一条在后台运行的工作，可以使用fg命令使它在前台运行，然后按^C结束该工作。 另一种选择是使用kill命令。 退出Shell可以使用exit命令或者按^D键退出当前shell。 定制Shell你可以定制你自己的shell一边更好的使用或工作。你可以在你的家目录找到并编辑.bash_profile或.bashrc来达到定制shell。它们可以定义变量或别名、运行程序、打印你的星座运势或者是任何你想做的事。"},{"title":"《Linux pocket guide》读书笔记之一：文件系统","permalink":"http://blog.zhiqing.info/2016/07/19/linux-pocket-guide-1/","text":"linux中文件系统为树形结构，并用/分隔，例：/home/zhiqing表示根目录下的home目录中的zhiqing文件夹 根目录：/（绝对路径以/开头） 家目录：～，例：～/Documents代表/home/username/Documents 父目录：..，例：../file代表上一级目录下的file文件 家目录普通用户的家目录为/home/username，超级用户（root）的家目录为/root 常用操作： 1234echo $HOME #显示当前用户的家目录echo ~ #同上cd ~/Documents #进入当前用户家目录中的Documents文件夹cd ~zhiqing #进入用户zhiqing的家目录 系统目录系统目录大致分为三部分：/Scope(域)/Category(分类)/Application(应用)。例如：/usr/local/share/emacs，其中usr/local为Scope，share为Category，emacs为Application。 Category（分类）分类通常指明了目录的类型，比如目录名为bin则代表该目录下存放的是可执行文件。常见分类如下： 程序类 bin 程序的二进制文件（可执行文件） sbin 程序的二进制文件（通常需要root权限） lib 程序的库文件 文档类 doc 文档 info emacs的内置文档 man 提供给man命令显示的文档 share 程序的特殊文件，如安装说明 配置类 etc 系统的配置文件和和各种其他的配置文件 init.d linux启动相关的配置文件 rc.d linux启动相关配置文件，按级别分类，如：rc1.d,rc2.d,… 编程类 include 头文件 src 程序源文件 网站类 cgi-bin 网站运行时的脚本或程序 html 网页文件 public_html 网页文件，通常存在与用户家目录 www 网页文件 硬件类 dev 磁盘或其他硬件的接口设备文件 media 挂载点：连接到外部磁盘 mnt 挂载点：链接到外部磁盘 运行时类 lock 锁文件 log 日志文件，包括错误、警告和提示信息 run PID文件 tmp 零时文件 proc 操作系统的状态 Scope（域）域通常包含了目录的描述 / linux的系统文件 /usr 更多的linux系统文件 /usr/local 为组织或个人开发的本地化的系统文件 /usr/games 游戏 一个分类会出现在多个域中，例如：/lib、/usr/lib、/usr/local/lib和/usr/games/lib可能会同时存在。 Application（应用）应用部分通常为程序名。系统目录中，在Scope和Category之后，每个应用都会有一个自己的子文件夹（如：/usr/local/doc/myprogram）用于存放自己需要的文件。 操作系统目录操作系统目录是保证系统内核运行的目录，最少要包含以下几个目录： 目录 作用 /boot 存放系统启动相关的文件，Linux内核(kernel)一般存放在/boot/vmlinuz或类似的目录中。 /lost+found 用于磁盘修复工具恢复已损坏文件 /proc 系统中正在运行的进程的描述 /proc 目录中的文件显示的是正在运行的内核和一些特殊的配置信息。它们的大小总是为0、修改时间为现在，并且权限为只读(-r–r–r–)。常见文件如下： 文件 含义 /proc/ioports 计算机中IO设备的列表 /proc/cpuinfo CPU的信息 /proc/version 操作系统的版本，同uname命令显示的内容 /proc/uptime 系统运行时间 文件保护linux中的权限包括：读(read)、写(write)、执行(execute) 读：读取文件内容、显示目录中的文件 写：修改或删除文件、创建或删除目录 执行：运行脚本或二进制文件、进入目录 执行ls -l file命令，每条记录前10个字符即为该文件的权限。表现形式类似：-rwxr-x---。解释如下： 位数 含义 1 文件类型（-为文件，d为目录，l为链接，p为管道，c为字符设备，b为块设备） 2-4 文件所有者的读、写、执行权限（为-则表示没有该权限） 5-7 文件所在组的读、写、执行权限 8-10 其他用户的读、写、执行权限 所以-rwxr-x---表示file是一个文件，该文件的所有者可以读、写、执行，该文件所所在组的用户可以读和执行，其他用户不能读、写和执行。"}]}